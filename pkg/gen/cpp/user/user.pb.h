// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: user/user.proto
// Protobuf C++ Version: 5.29.3

#ifndef user_2fuser_2eproto_2epb_2eh
#define user_2fuser_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_user_2fuser_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2fuser_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_user_2fuser_2eproto;
namespace user {
class CreateRoleRequest;
struct CreateRoleRequestDefaultTypeInternal;
extern CreateRoleRequestDefaultTypeInternal _CreateRoleRequest_default_instance_;
class CreateRoleResponse;
struct CreateRoleResponseDefaultTypeInternal;
extern CreateRoleResponseDefaultTypeInternal _CreateRoleResponse_default_instance_;
class CreateUserRequest;
struct CreateUserRequestDefaultTypeInternal;
extern CreateUserRequestDefaultTypeInternal _CreateUserRequest_default_instance_;
class CreateUserResponse;
struct CreateUserResponseDefaultTypeInternal;
extern CreateUserResponseDefaultTypeInternal _CreateUserResponse_default_instance_;
class DeleteRoleRequest;
struct DeleteRoleRequestDefaultTypeInternal;
extern DeleteRoleRequestDefaultTypeInternal _DeleteRoleRequest_default_instance_;
class DeleteRoleResponse;
struct DeleteRoleResponseDefaultTypeInternal;
extern DeleteRoleResponseDefaultTypeInternal _DeleteRoleResponse_default_instance_;
class DeleteUserRequest;
struct DeleteUserRequestDefaultTypeInternal;
extern DeleteUserRequestDefaultTypeInternal _DeleteUserRequest_default_instance_;
class DeleteUserResponse;
struct DeleteUserResponseDefaultTypeInternal;
extern DeleteUserResponseDefaultTypeInternal _DeleteUserResponse_default_instance_;
class GetUserRequest;
struct GetUserRequestDefaultTypeInternal;
extern GetUserRequestDefaultTypeInternal _GetUserRequest_default_instance_;
class GetUserResponse;
struct GetUserResponseDefaultTypeInternal;
extern GetUserResponseDefaultTypeInternal _GetUserResponse_default_instance_;
class ListRolesRequest;
struct ListRolesRequestDefaultTypeInternal;
extern ListRolesRequestDefaultTypeInternal _ListRolesRequest_default_instance_;
class ListRolesResponse;
struct ListRolesResponseDefaultTypeInternal;
extern ListRolesResponseDefaultTypeInternal _ListRolesResponse_default_instance_;
class ListUsersRequest;
struct ListUsersRequestDefaultTypeInternal;
extern ListUsersRequestDefaultTypeInternal _ListUsersRequest_default_instance_;
class ListUsersResponse;
struct ListUsersResponseDefaultTypeInternal;
extern ListUsersResponseDefaultTypeInternal _ListUsersResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class PatchUserRequest;
struct PatchUserRequestDefaultTypeInternal;
extern PatchUserRequestDefaultTypeInternal _PatchUserRequest_default_instance_;
class PatchUserResponse;
struct PatchUserResponseDefaultTypeInternal;
extern PatchUserResponseDefaultTypeInternal _PatchUserResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RoleModel;
struct RoleModelDefaultTypeInternal;
extern RoleModelDefaultTypeInternal _RoleModel_default_instance_;
class UpdateRoleRequest;
struct UpdateRoleRequestDefaultTypeInternal;
extern UpdateRoleRequestDefaultTypeInternal _UpdateRoleRequest_default_instance_;
class UpdateRoleResponse;
struct UpdateRoleResponseDefaultTypeInternal;
extern UpdateRoleResponseDefaultTypeInternal _UpdateRoleResponse_default_instance_;
class UpdateUserRequest;
struct UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserResponse;
struct UpdateUserResponseDefaultTypeInternal;
extern UpdateUserResponseDefaultTypeInternal _UpdateUserResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserModel;
struct UserModelDefaultTypeInternal;
extern UserModelDefaultTypeInternal _UserModel_default_instance_;
class UserRoleModel;
struct UserRoleModelDefaultTypeInternal;
extern UserRoleModelDefaultTypeInternal _UserRoleModel_default_instance_;
}  // namespace user
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace user {

// ===================================================================


// -------------------------------------------------------------------

class UserRoleModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UserRoleModel) */ {
 public:
  inline UserRoleModel() : UserRoleModel(nullptr) {}
  ~UserRoleModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserRoleModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserRoleModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserRoleModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserRoleModel(const UserRoleModel& from) : UserRoleModel(nullptr, from) {}
  inline UserRoleModel(UserRoleModel&& from) noexcept
      : UserRoleModel(nullptr, std::move(from)) {}
  inline UserRoleModel& operator=(const UserRoleModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRoleModel& operator=(UserRoleModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRoleModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRoleModel* internal_default_instance() {
    return reinterpret_cast<const UserRoleModel*>(
        &_UserRoleModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(UserRoleModel& a, UserRoleModel& b) { a.Swap(&b); }
  inline void Swap(UserRoleModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRoleModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRoleModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserRoleModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserRoleModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserRoleModel& from) { UserRoleModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserRoleModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UserRoleModel"; }

 protected:
  explicit UserRoleModel(::google::protobuf::Arena* arena);
  UserRoleModel(::google::protobuf::Arena* arena, const UserRoleModel& from);
  UserRoleModel(::google::protobuf::Arena* arena, UserRoleModel&& from) noexcept
      : UserRoleModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kRoleIdFieldNumber = 2,
    kAssignedByFieldNumber = 3,
    kOrganizationIdFieldNumber = 4,
  };
  // optional int64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id() ;
  ::int64_t user_id() const;
  void set_user_id(::int64_t value);

  private:
  ::int64_t _internal_user_id() const;
  void _internal_set_user_id(::int64_t value);

  public:
  // int64 role_id = 2;
  void clear_role_id() ;
  ::int64_t role_id() const;
  void set_role_id(::int64_t value);

  private:
  ::int64_t _internal_role_id() const;
  void _internal_set_role_id(::int64_t value);

  public:
  // int64 assigned_by = 3;
  void clear_assigned_by() ;
  ::int64_t assigned_by() const;
  void set_assigned_by(::int64_t value);

  private:
  ::int64_t _internal_assigned_by() const;
  void _internal_set_assigned_by(::int64_t value);

  public:
  // int64 organization_id = 4;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.UserRoleModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserRoleModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t user_id_;
    ::int64_t role_id_;
    ::int64_t assigned_by_;
    ::int64_t organization_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UserModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UserModel) */ {
 public:
  inline UserModel() : UserModel(nullptr) {}
  ~UserModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserModel(const UserModel& from) : UserModel(nullptr, from) {}
  inline UserModel(UserModel&& from) noexcept
      : UserModel(nullptr, std::move(from)) {}
  inline UserModel& operator=(const UserModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserModel& operator=(UserModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserModel* internal_default_instance() {
    return reinterpret_cast<const UserModel*>(
        &_UserModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UserModel& a, UserModel& b) { a.Swap(&b); }
  inline void Swap(UserModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserModel& from) { UserModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UserModel"; }

 protected:
  explicit UserModel(::google::protobuf::Arena* arena);
  UserModel(::google::protobuf::Arena* arena, const UserModel& from);
  UserModel(::google::protobuf::Arena* arena, UserModel&& from) noexcept
      : UserModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmailFieldNumber = 2,
    kPasswordHashFieldNumber = 3,
    kFirstNameFieldNumber = 4,
    kLastNameFieldNumber = 5,
    kPhoneNumberFieldNumber = 6,
    kOrganizationTypeFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kUpdatedAtFieldNumber = 10,
    kIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 7,
  };
  // optional string email = 2;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string password_hash = 3;
  bool has_password_hash() const;
  void clear_password_hash() ;
  const std::string& password_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password_hash(Arg_&& arg, Args_... args);
  std::string* mutable_password_hash();
  PROTOBUF_NODISCARD std::string* release_password_hash();
  void set_allocated_password_hash(std::string* value);

  private:
  const std::string& _internal_password_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_hash(
      const std::string& value);
  std::string* _internal_mutable_password_hash();

  public:
  // optional string first_name = 4;
  bool has_first_name() const;
  void clear_first_name() ;
  const std::string& first_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_first_name(Arg_&& arg, Args_... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* value);

  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(
      const std::string& value);
  std::string* _internal_mutable_first_name();

  public:
  // optional string last_name = 5;
  bool has_last_name() const;
  void clear_last_name() ;
  const std::string& last_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_name(Arg_&& arg, Args_... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* value);

  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(
      const std::string& value);
  std::string* _internal_mutable_last_name();

  public:
  // optional string phone_number = 6;
  bool has_phone_number() const;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // optional string organization_type = 8;
  bool has_organization_type() const;
  void clear_organization_type() ;
  const std::string& organization_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_organization_type(Arg_&& arg, Args_... args);
  std::string* mutable_organization_type();
  PROTOBUF_NODISCARD std::string* release_organization_type();
  void set_allocated_organization_type(std::string* value);

  private:
  const std::string& _internal_organization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_type(
      const std::string& value);
  std::string* _internal_mutable_organization_type();

  public:
  // optional string created_at = 9;
  bool has_created_at() const;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // optional string updated_at = 10;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const std::string& updated_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_at(Arg_&& arg, Args_... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* value);

  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(
      const std::string& value);
  std::string* _internal_mutable_updated_at();

  public:
  // optional int64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional int64 organization_id = 7;
  bool has_organization_id() const;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.UserModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      117, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_hash_;
    ::google::protobuf::internal::ArenaStringPtr first_name_;
    ::google::protobuf::internal::ArenaStringPtr last_name_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr organization_type_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr updated_at_;
    ::int64_t id_;
    ::int64_t organization_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RoleModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.RoleModel) */ {
 public:
  inline RoleModel() : RoleModel(nullptr) {}
  ~RoleModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoleModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoleModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoleModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoleModel(const RoleModel& from) : RoleModel(nullptr, from) {}
  inline RoleModel(RoleModel&& from) noexcept
      : RoleModel(nullptr, std::move(from)) {}
  inline RoleModel& operator=(const RoleModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleModel& operator=(RoleModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleModel* internal_default_instance() {
    return reinterpret_cast<const RoleModel*>(
        &_RoleModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RoleModel& a, RoleModel& b) { a.Swap(&b); }
  inline void Swap(RoleModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoleModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoleModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoleModel& from) { RoleModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoleModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.RoleModel"; }

 protected:
  explicit RoleModel(::google::protobuf::Arena* arena);
  RoleModel(::google::protobuf::Arena* arena, const RoleModel& from);
  RoleModel(::google::protobuf::Arena* arena, RoleModel&& from) noexcept
      : RoleModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kRoleIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 4,
  };
  // string role_name = 2;
  void clear_role_name() ;
  const std::string& role_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role_name(Arg_&& arg, Args_... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* value);

  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(
      const std::string& value);
  std::string* _internal_mutable_role_name();

  public:
  // optional string description = 3;
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional int64 role_id = 1;
  bool has_role_id() const;
  void clear_role_id() ;
  ::int64_t role_id() const;
  void set_role_id(::int64_t value);

  private:
  ::int64_t _internal_role_id() const;
  void _internal_set_role_id(::int64_t value);

  public:
  // optional int64 organization_id = 4;
  bool has_organization_id() const;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.RoleModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RoleModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr role_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::int64_t role_id_;
    ::int64_t organization_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoginRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoginRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from) : LoginRequest(nullptr, from) {}
  inline LoginRequest(LoginRequest&& from) noexcept
      : LoginRequest(nullptr, std::move(from)) {}
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
        &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(LoginRequest& a, LoginRequest& b) { a.Swap(&b); }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from) { LoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoginRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.LoginRequest"; }

 protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  LoginRequest(::google::protobuf::Arena* arena, LoginRequest&& from) noexcept
      : LoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoginFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string login = 1;
  void clear_login() ;
  const std::string& login() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_login(Arg_&& arg, Args_... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* value);

  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(
      const std::string& value);
  std::string* _internal_mutable_login();

  public:
  // string platform = 2;
  void clear_platform() ;
  const std::string& platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* value);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // string password = 3;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:user.LoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr login_;
    ::google::protobuf::internal::ArenaStringPtr platform_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUsersRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.ListUsersRequest) */ {
 public:
  inline ListUsersRequest() : ListUsersRequest(nullptr) {}
  ~ListUsersRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListUsersRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListUsersRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListUsersRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListUsersRequest(const ListUsersRequest& from) : ListUsersRequest(nullptr, from) {}
  inline ListUsersRequest(ListUsersRequest&& from) noexcept
      : ListUsersRequest(nullptr, std::move(from)) {}
  inline ListUsersRequest& operator=(const ListUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersRequest& operator=(ListUsersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListUsersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListUsersRequest* internal_default_instance() {
    return reinterpret_cast<const ListUsersRequest*>(
        &_ListUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ListUsersRequest& a, ListUsersRequest& b) { a.Swap(&b); }
  inline void Swap(ListUsersRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListUsersRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListUsersRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListUsersRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListUsersRequest& from) { ListUsersRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListUsersRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.ListUsersRequest"; }

 protected:
  explicit ListUsersRequest(::google::protobuf::Arena* arena);
  ListUsersRequest(::google::protobuf::Arena* arena, const ListUsersRequest& from);
  ListUsersRequest(::google::protobuf::Arena* arena, ListUsersRequest&& from) noexcept
      : ListUsersRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // int64 organization_id = 1;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.ListUsersRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListUsersRequest& from_msg);
    ::int64_t organization_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListRolesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.ListRolesRequest) */ {
 public:
  inline ListRolesRequest() : ListRolesRequest(nullptr) {}
  ~ListRolesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListRolesRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListRolesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListRolesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListRolesRequest(const ListRolesRequest& from) : ListRolesRequest(nullptr, from) {}
  inline ListRolesRequest(ListRolesRequest&& from) noexcept
      : ListRolesRequest(nullptr, std::move(from)) {}
  inline ListRolesRequest& operator=(const ListRolesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRolesRequest& operator=(ListRolesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRolesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRolesRequest* internal_default_instance() {
    return reinterpret_cast<const ListRolesRequest*>(
        &_ListRolesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ListRolesRequest& a, ListRolesRequest& b) { a.Swap(&b); }
  inline void Swap(ListRolesRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRolesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRolesRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListRolesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRolesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListRolesRequest& from) { ListRolesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListRolesRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.ListRolesRequest"; }

 protected:
  explicit ListRolesRequest(::google::protobuf::Arena* arena);
  ListRolesRequest(::google::protobuf::Arena* arena, const ListRolesRequest& from);
  ListRolesRequest(::google::protobuf::Arena* arena, ListRolesRequest&& from) noexcept
      : ListRolesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // int64 organization_id = 1;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.ListRolesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListRolesRequest& from_msg);
    ::int64_t organization_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.GetUserRequest) */ {
 public:
  inline GetUserRequest() : GetUserRequest(nullptr) {}
  ~GetUserRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetUserRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetUserRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetUserRequest(const GetUserRequest& from) : GetUserRequest(nullptr, from) {}
  inline GetUserRequest(GetUserRequest&& from) noexcept
      : GetUserRequest(nullptr, std::move(from)) {}
  inline GetUserRequest& operator=(const GetUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserRequest& operator=(GetUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserRequest*>(
        &_GetUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GetUserRequest& a, GetUserRequest& b) { a.Swap(&b); }
  inline void Swap(GetUserRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetUserRequest& from) { GetUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetUserRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.GetUserRequest"; }

 protected:
  explicit GetUserRequest(::google::protobuf::Arena* arena);
  GetUserRequest(::google::protobuf::Arena* arena, const GetUserRequest& from);
  GetUserRequest(::google::protobuf::Arena* arena, GetUserRequest&& from) noexcept
      : GetUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // int64 user_id = 1;
  void clear_user_id() ;
  ::int64_t user_id() const;
  void set_user_id(::int64_t value);

  private:
  ::int64_t _internal_user_id() const;
  void _internal_set_user_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.GetUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetUserRequest& from_msg);
    ::int64_t user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.DeleteUserResponse) */ {
 public:
  inline DeleteUserResponse() : DeleteUserResponse(nullptr) {}
  ~DeleteUserResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteUserResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteUserResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteUserResponse(const DeleteUserResponse& from) : DeleteUserResponse(nullptr, from) {}
  inline DeleteUserResponse(DeleteUserResponse&& from) noexcept
      : DeleteUserResponse(nullptr, std::move(from)) {}
  inline DeleteUserResponse& operator=(const DeleteUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserResponse& operator=(DeleteUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteUserResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteUserResponse*>(
        &_DeleteUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(DeleteUserResponse& a, DeleteUserResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteUserResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteUserResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteUserResponse& from) { DeleteUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteUserResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.DeleteUserResponse"; }

 protected:
  explicit DeleteUserResponse(::google::protobuf::Arena* arena);
  DeleteUserResponse(::google::protobuf::Arena* arena, const DeleteUserResponse& from);
  DeleteUserResponse(::google::protobuf::Arena* arena, DeleteUserResponse&& from) noexcept
      : DeleteUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:user.DeleteUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteUserResponse& from_msg);
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.DeleteUserRequest) */ {
 public:
  inline DeleteUserRequest() : DeleteUserRequest(nullptr) {}
  ~DeleteUserRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteUserRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteUserRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteUserRequest(const DeleteUserRequest& from) : DeleteUserRequest(nullptr, from) {}
  inline DeleteUserRequest(DeleteUserRequest&& from) noexcept
      : DeleteUserRequest(nullptr, std::move(from)) {}
  inline DeleteUserRequest& operator=(const DeleteUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserRequest& operator=(DeleteUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteUserRequest*>(
        &_DeleteUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(DeleteUserRequest& a, DeleteUserRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteUserRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteUserRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteUserRequest& from) { DeleteUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteUserRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.DeleteUserRequest"; }

 protected:
  explicit DeleteUserRequest(::google::protobuf::Arena* arena);
  DeleteUserRequest(::google::protobuf::Arena* arena, const DeleteUserRequest& from);
  DeleteUserRequest(::google::protobuf::Arena* arena, DeleteUserRequest&& from) noexcept
      : DeleteUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // int64 user_id = 1;
  void clear_user_id() ;
  ::int64_t user_id() const;
  void set_user_id(::int64_t value);

  private:
  ::int64_t _internal_user_id() const;
  void _internal_set_user_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.DeleteUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteUserRequest& from_msg);
    ::int64_t user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoleResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.DeleteRoleResponse) */ {
 public:
  inline DeleteRoleResponse() : DeleteRoleResponse(nullptr) {}
  ~DeleteRoleResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteRoleResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteRoleResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRoleResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteRoleResponse(const DeleteRoleResponse& from) : DeleteRoleResponse(nullptr, from) {}
  inline DeleteRoleResponse(DeleteRoleResponse&& from) noexcept
      : DeleteRoleResponse(nullptr, std::move(from)) {}
  inline DeleteRoleResponse& operator=(const DeleteRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoleResponse& operator=(DeleteRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRoleResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRoleResponse*>(
        &_DeleteRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(DeleteRoleResponse& a, DeleteRoleResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteRoleResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRoleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRoleResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteRoleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteRoleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteRoleResponse& from) { DeleteRoleResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteRoleResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.DeleteRoleResponse"; }

 protected:
  explicit DeleteRoleResponse(::google::protobuf::Arena* arena);
  DeleteRoleResponse(::google::protobuf::Arena* arena, const DeleteRoleResponse& from);
  DeleteRoleResponse(::google::protobuf::Arena* arena, DeleteRoleResponse&& from) noexcept
      : DeleteRoleResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:user.DeleteRoleResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteRoleResponse& from_msg);
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoleRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.DeleteRoleRequest) */ {
 public:
  inline DeleteRoleRequest() : DeleteRoleRequest(nullptr) {}
  ~DeleteRoleRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteRoleRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteRoleRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRoleRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteRoleRequest(const DeleteRoleRequest& from) : DeleteRoleRequest(nullptr, from) {}
  inline DeleteRoleRequest(DeleteRoleRequest&& from) noexcept
      : DeleteRoleRequest(nullptr, std::move(from)) {}
  inline DeleteRoleRequest& operator=(const DeleteRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoleRequest& operator=(DeleteRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRoleRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRoleRequest*>(
        &_DeleteRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(DeleteRoleRequest& a, DeleteRoleRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteRoleRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteRoleRequest& from) { DeleteRoleRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteRoleRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.DeleteRoleRequest"; }

 protected:
  explicit DeleteRoleRequest(::google::protobuf::Arena* arena);
  DeleteRoleRequest(::google::protobuf::Arena* arena, const DeleteRoleRequest& from);
  DeleteRoleRequest(::google::protobuf::Arena* arena, DeleteRoleRequest&& from) noexcept
      : DeleteRoleRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int64 role_id = 1;
  void clear_role_id() ;
  ::int64_t role_id() const;
  void set_role_id(::int64_t value);

  private:
  ::int64_t _internal_role_id() const;
  void _internal_set_role_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.DeleteRoleRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteRoleRequest& from_msg);
    ::int64_t role_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmailFieldNumber = 2,
    kPasswordHashFieldNumber = 3,
    kPhoneNumberFieldNumber = 4,
    kFirstNameFieldNumber = 5,
    kLastNameFieldNumber = 6,
    kOrganizationNameFieldNumber = 8,
    kOrganizationTypeFieldNumber = 9,
    kCreatedAtFieldNumber = 10,
    kUpdatedAtFieldNumber = 11,
    kRoleFieldNumber = 12,
    kIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 7,
  };
  // optional string email = 2;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string password_hash = 3;
  bool has_password_hash() const;
  void clear_password_hash() ;
  const std::string& password_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password_hash(Arg_&& arg, Args_... args);
  std::string* mutable_password_hash();
  PROTOBUF_NODISCARD std::string* release_password_hash();
  void set_allocated_password_hash(std::string* value);

  private:
  const std::string& _internal_password_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_hash(
      const std::string& value);
  std::string* _internal_mutable_password_hash();

  public:
  // optional string phone_number = 4;
  bool has_phone_number() const;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // optional string first_name = 5;
  bool has_first_name() const;
  void clear_first_name() ;
  const std::string& first_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_first_name(Arg_&& arg, Args_... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* value);

  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(
      const std::string& value);
  std::string* _internal_mutable_first_name();

  public:
  // optional string last_name = 6;
  bool has_last_name() const;
  void clear_last_name() ;
  const std::string& last_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_name(Arg_&& arg, Args_... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* value);

  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(
      const std::string& value);
  std::string* _internal_mutable_last_name();

  public:
  // optional string organization_name = 8;
  bool has_organization_name() const;
  void clear_organization_name() ;
  const std::string& organization_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_organization_name(Arg_&& arg, Args_... args);
  std::string* mutable_organization_name();
  PROTOBUF_NODISCARD std::string* release_organization_name();
  void set_allocated_organization_name(std::string* value);

  private:
  const std::string& _internal_organization_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_name(
      const std::string& value);
  std::string* _internal_mutable_organization_name();

  public:
  // optional string organization_type = 9;
  bool has_organization_type() const;
  void clear_organization_type() ;
  const std::string& organization_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_organization_type(Arg_&& arg, Args_... args);
  std::string* mutable_organization_type();
  PROTOBUF_NODISCARD std::string* release_organization_type();
  void set_allocated_organization_type(std::string* value);

  private:
  const std::string& _internal_organization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_type(
      const std::string& value);
  std::string* _internal_mutable_organization_type();

  public:
  // optional string created_at = 10;
  bool has_created_at() const;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // optional string updated_at = 11;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const std::string& updated_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_at(Arg_&& arg, Args_... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* value);

  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(
      const std::string& value);
  std::string* _internal_mutable_updated_at();

  public:
  // optional .user.RoleModel role = 12;
  bool has_role() const;
  void clear_role() ;
  const ::user::RoleModel& role() const;
  PROTOBUF_NODISCARD ::user::RoleModel* release_role();
  ::user::RoleModel* mutable_role();
  void set_allocated_role(::user::RoleModel* value);
  void unsafe_arena_set_allocated_role(::user::RoleModel* value);
  ::user::RoleModel* unsafe_arena_release_role();

  private:
  const ::user::RoleModel& _internal_role() const;
  ::user::RoleModel* _internal_mutable_role();

  public:
  // optional int64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional int64 organization_id = 7;
  bool has_organization_id() const;
  void clear_organization_id() ;
  ::int64_t organization_id() const;
  void set_organization_id(::int64_t value);

  private:
  ::int64_t _internal_organization_id() const;
  void _internal_set_organization_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      129, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_hash_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr first_name_;
    ::google::protobuf::internal::ArenaStringPtr last_name_;
    ::google::protobuf::internal::ArenaStringPtr organization_name_;
    ::google::protobuf::internal::ArenaStringPtr organization_type_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr updated_at_;
    ::user::RoleModel* role_;
    ::int64_t id_;
    ::int64_t organization_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UpdateUserResponse) */ {
 public:
  inline UpdateUserResponse() : UpdateUserResponse(nullptr) {}
  ~UpdateUserResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateUserResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateUserResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUserResponse(const UpdateUserResponse& from) : UpdateUserResponse(nullptr, from) {}
  inline UpdateUserResponse(UpdateUserResponse&& from) noexcept
      : UpdateUserResponse(nullptr, std::move(from)) {}
  inline UpdateUserResponse& operator=(const UpdateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserResponse& operator=(UpdateUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserResponse*>(
        &_UpdateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(UpdateUserResponse& a, UpdateUserResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateUserResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUserResponse& from) { UpdateUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateUserResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UpdateUserResponse"; }

 protected:
  explicit UpdateUserResponse(::google::protobuf::Arena* arena);
  UpdateUserResponse(::google::protobuf::Arena* arena, const UpdateUserResponse& from);
  UpdateUserResponse(::google::protobuf::Arena* arena, UpdateUserResponse&& from) noexcept
      : UpdateUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.UserModel user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::UserModel& user() const;
  PROTOBUF_NODISCARD ::user::UserModel* release_user();
  ::user::UserModel* mutable_user();
  void set_allocated_user(::user::UserModel* value);
  void unsafe_arena_set_allocated_user(::user::UserModel* value);
  ::user::UserModel* unsafe_arena_release_user();

  private:
  const ::user::UserModel& _internal_user() const;
  ::user::UserModel* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.UpdateUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateUserResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::UserModel* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {}
  ~UpdateUserRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateUserRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateUserRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUserRequest(const UpdateUserRequest& from) : UpdateUserRequest(nullptr, from) {}
  inline UpdateUserRequest(UpdateUserRequest&& from) noexcept
      : UpdateUserRequest(nullptr, std::move(from)) {}
  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
        &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUserRequest& from) { UpdateUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateUserRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UpdateUserRequest"; }

 protected:
  explicit UpdateUserRequest(::google::protobuf::Arena* arena);
  UpdateUserRequest(::google::protobuf::Arena* arena, const UpdateUserRequest& from);
  UpdateUserRequest(::google::protobuf::Arena* arena, UpdateUserRequest&& from) noexcept
      : UpdateUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.UserModel user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::UserModel& user() const;
  PROTOBUF_NODISCARD ::user::UserModel* release_user();
  ::user::UserModel* mutable_user();
  void set_allocated_user(::user::UserModel* value);
  void unsafe_arena_set_allocated_user(::user::UserModel* value);
  ::user::UserModel* unsafe_arena_release_user();

  private:
  const ::user::UserModel& _internal_user() const;
  ::user::UserModel* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.UpdateUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateUserRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::UserModel* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateRoleResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UpdateRoleResponse) */ {
 public:
  inline UpdateRoleResponse() : UpdateRoleResponse(nullptr) {}
  ~UpdateRoleResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateRoleResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateRoleResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRoleResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateRoleResponse(const UpdateRoleResponse& from) : UpdateRoleResponse(nullptr, from) {}
  inline UpdateRoleResponse(UpdateRoleResponse&& from) noexcept
      : UpdateRoleResponse(nullptr, std::move(from)) {}
  inline UpdateRoleResponse& operator=(const UpdateRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRoleResponse& operator=(UpdateRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRoleResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRoleResponse*>(
        &_UpdateRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(UpdateRoleResponse& a, UpdateRoleResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateRoleResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRoleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRoleResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateRoleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRoleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateRoleResponse& from) { UpdateRoleResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateRoleResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UpdateRoleResponse"; }

 protected:
  explicit UpdateRoleResponse(::google::protobuf::Arena* arena);
  UpdateRoleResponse(::google::protobuf::Arena* arena, const UpdateRoleResponse& from);
  UpdateRoleResponse(::google::protobuf::Arena* arena, UpdateRoleResponse&& from) noexcept
      : UpdateRoleResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleFieldNumber = 1,
  };
  // .user.RoleModel role = 1;
  bool has_role() const;
  void clear_role() ;
  const ::user::RoleModel& role() const;
  PROTOBUF_NODISCARD ::user::RoleModel* release_role();
  ::user::RoleModel* mutable_role();
  void set_allocated_role(::user::RoleModel* value);
  void unsafe_arena_set_allocated_role(::user::RoleModel* value);
  ::user::RoleModel* unsafe_arena_release_role();

  private:
  const ::user::RoleModel& _internal_role() const;
  ::user::RoleModel* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:user.UpdateRoleResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateRoleResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::RoleModel* role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateRoleRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.UpdateRoleRequest) */ {
 public:
  inline UpdateRoleRequest() : UpdateRoleRequest(nullptr) {}
  ~UpdateRoleRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateRoleRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateRoleRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRoleRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateRoleRequest(const UpdateRoleRequest& from) : UpdateRoleRequest(nullptr, from) {}
  inline UpdateRoleRequest(UpdateRoleRequest&& from) noexcept
      : UpdateRoleRequest(nullptr, std::move(from)) {}
  inline UpdateRoleRequest& operator=(const UpdateRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRoleRequest& operator=(UpdateRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRoleRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRoleRequest*>(
        &_UpdateRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(UpdateRoleRequest& a, UpdateRoleRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateRoleRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateRoleRequest& from) { UpdateRoleRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateRoleRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.UpdateRoleRequest"; }

 protected:
  explicit UpdateRoleRequest(::google::protobuf::Arena* arena);
  UpdateRoleRequest(::google::protobuf::Arena* arena, const UpdateRoleRequest& from);
  UpdateRoleRequest(::google::protobuf::Arena* arena, UpdateRoleRequest&& from) noexcept
      : UpdateRoleRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleFieldNumber = 1,
  };
  // .user.RoleModel role = 1;
  bool has_role() const;
  void clear_role() ;
  const ::user::RoleModel& role() const;
  PROTOBUF_NODISCARD ::user::RoleModel* release_role();
  ::user::RoleModel* mutable_role();
  void set_allocated_role(::user::RoleModel* value);
  void unsafe_arena_set_allocated_role(::user::RoleModel* value);
  ::user::RoleModel* unsafe_arena_release_role();

  private:
  const ::user::RoleModel& _internal_role() const;
  ::user::RoleModel* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:user.UpdateRoleRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateRoleRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::RoleModel* role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterResponse(const RegisterResponse& from) : RegisterResponse(nullptr, from) {}
  inline RegisterResponse(RegisterResponse&& from) noexcept
      : RegisterResponse(nullptr, std::move(from)) {}
  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
        &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RegisterResponse& a, RegisterResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterResponse& from) { RegisterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.RegisterResponse"; }

 protected:
  explicit RegisterResponse(::google::protobuf::Arena* arena);
  RegisterResponse(::google::protobuf::Arena* arena, const RegisterResponse& from);
  RegisterResponse(::google::protobuf::Arena* arena, RegisterResponse&& from) noexcept
      : RegisterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .user.UserModel user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::user::UserModel& user() const;
  PROTOBUF_NODISCARD ::user::UserModel* release_user();
  ::user::UserModel* mutable_user();
  void set_allocated_user(::user::UserModel* value);
  void unsafe_arena_set_allocated_user(::user::UserModel* value);
  ::user::UserModel* unsafe_arena_release_user();

  private:
  const ::user::UserModel& _internal_user() const;
  ::user::UserModel* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.RegisterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::user::UserModel* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterRequest(const RegisterRequest& from) : RegisterRequest(nullptr, from) {}
  inline RegisterRequest(RegisterRequest&& from) noexcept
      : RegisterRequest(nullptr, std::move(from)) {}
  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
        &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RegisterRequest& a, RegisterRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from) { RegisterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.RegisterRequest"; }

 protected:
  explicit RegisterRequest(::google::protobuf::Arena* arena);
  RegisterRequest(::google::protobuf::Arena* arena, const RegisterRequest& from);
  RegisterRequest(::google::protobuf::Arena* arena, RegisterRequest&& from) noexcept
      : RegisterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.UserModel user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::UserModel& user() const;
  PROTOBUF_NODISCARD ::user::UserModel* release_user();
  ::user::UserModel* mutable_user();
  void set_allocated_user(::user::UserModel* value);
  void unsafe_arena_set_allocated_user(::user::UserModel* value);
  ::user::UserModel* unsafe_arena_release_user();

  private:
  const ::user::UserModel& _internal_user() const;
  ::user::UserModel* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.RegisterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::UserModel* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListRolesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.ListRolesResponse) */ {
 public:
  inline ListRolesResponse() : ListRolesResponse(nullptr) {}
  ~ListRolesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListRolesResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListRolesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListRolesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListRolesResponse(const ListRolesResponse& from) : ListRolesResponse(nullptr, from) {}
  inline ListRolesResponse(ListRolesResponse&& from) noexcept
      : ListRolesResponse(nullptr, std::move(from)) {}
  inline ListRolesResponse& operator=(const ListRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRolesResponse& operator=(ListRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRolesResponse* internal_default_instance() {
    return reinterpret_cast<const ListRolesResponse*>(
        &_ListRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ListRolesResponse& a, ListRolesResponse& b) { a.Swap(&b); }
  inline void Swap(ListRolesResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRolesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRolesResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListRolesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRolesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListRolesResponse& from) { ListRolesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListRolesResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.ListRolesResponse"; }

 protected:
  explicit ListRolesResponse(::google::protobuf::Arena* arena);
  ListRolesResponse(::google::protobuf::Arena* arena, const ListRolesResponse& from);
  ListRolesResponse(::google::protobuf::Arena* arena, ListRolesResponse&& from) noexcept
      : ListRolesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRolesFieldNumber = 1,
    kTotalCountFieldNumber = 2,
  };
  // repeated .user.RoleModel roles = 1;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  ::user::RoleModel* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField<::user::RoleModel>* mutable_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<::user::RoleModel>& _internal_roles() const;
  ::google::protobuf::RepeatedPtrField<::user::RoleModel>* _internal_mutable_roles();
  public:
  const ::user::RoleModel& roles(int index) const;
  ::user::RoleModel* add_roles();
  const ::google::protobuf::RepeatedPtrField<::user::RoleModel>& roles() const;
  // int32 total_count = 2;
  void clear_total_count() ;
  ::int32_t total_count() const;
  void set_total_count(::int32_t value);

  private:
  ::int32_t _internal_total_count() const;
  void _internal_set_total_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.ListRolesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListRolesResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::user::RoleModel > roles_;
    ::int32_t total_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateRoleResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.CreateRoleResponse) */ {
 public:
  inline CreateRoleResponse() : CreateRoleResponse(nullptr) {}
  ~CreateRoleResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateRoleResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateRoleResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateRoleResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateRoleResponse(const CreateRoleResponse& from) : CreateRoleResponse(nullptr, from) {}
  inline CreateRoleResponse(CreateRoleResponse&& from) noexcept
      : CreateRoleResponse(nullptr, std::move(from)) {}
  inline CreateRoleResponse& operator=(const CreateRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoleResponse& operator=(CreateRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoleResponse*>(
        &_CreateRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(CreateRoleResponse& a, CreateRoleResponse& b) { a.Swap(&b); }
  inline void Swap(CreateRoleResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoleResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateRoleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateRoleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateRoleResponse& from) { CreateRoleResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateRoleResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.CreateRoleResponse"; }

 protected:
  explicit CreateRoleResponse(::google::protobuf::Arena* arena);
  CreateRoleResponse(::google::protobuf::Arena* arena, const CreateRoleResponse& from);
  CreateRoleResponse(::google::protobuf::Arena* arena, CreateRoleResponse&& from) noexcept
      : CreateRoleResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleFieldNumber = 1,
  };
  // .user.RoleModel role = 1;
  bool has_role() const;
  void clear_role() ;
  const ::user::RoleModel& role() const;
  PROTOBUF_NODISCARD ::user::RoleModel* release_role();
  ::user::RoleModel* mutable_role();
  void set_allocated_role(::user::RoleModel* value);
  void unsafe_arena_set_allocated_role(::user::RoleModel* value);
  ::user::RoleModel* unsafe_arena_release_role();

  private:
  const ::user::RoleModel& _internal_role() const;
  ::user::RoleModel* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:user.CreateRoleResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateRoleResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::RoleModel* role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateRoleRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.CreateRoleRequest) */ {
 public:
  inline CreateRoleRequest() : CreateRoleRequest(nullptr) {}
  ~CreateRoleRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateRoleRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateRoleRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateRoleRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateRoleRequest(const CreateRoleRequest& from) : CreateRoleRequest(nullptr, from) {}
  inline CreateRoleRequest(CreateRoleRequest&& from) noexcept
      : CreateRoleRequest(nullptr, std::move(from)) {}
  inline CreateRoleRequest& operator=(const CreateRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoleRequest& operator=(CreateRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoleRequest*>(
        &_CreateRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CreateRoleRequest& a, CreateRoleRequest& b) { a.Swap(&b); }
  inline void Swap(CreateRoleRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateRoleRequest& from) { CreateRoleRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateRoleRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.CreateRoleRequest"; }

 protected:
  explicit CreateRoleRequest(::google::protobuf::Arena* arena);
  CreateRoleRequest(::google::protobuf::Arena* arena, const CreateRoleRequest& from);
  CreateRoleRequest(::google::protobuf::Arena* arena, CreateRoleRequest&& from) noexcept
      : CreateRoleRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoleFieldNumber = 1,
  };
  // .user.RoleModel role = 1;
  bool has_role() const;
  void clear_role() ;
  const ::user::RoleModel& role() const;
  PROTOBUF_NODISCARD ::user::RoleModel* release_role();
  ::user::RoleModel* mutable_role();
  void set_allocated_role(::user::RoleModel* value);
  void unsafe_arena_set_allocated_role(::user::RoleModel* value);
  ::user::RoleModel* unsafe_arena_release_role();

  private:
  const ::user::RoleModel& _internal_role() const;
  ::user::RoleModel* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:user.CreateRoleRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateRoleRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::RoleModel* role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class PatchUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.PatchUserResponse) */ {
 public:
  inline PatchUserResponse() : PatchUserResponse(nullptr) {}
  ~PatchUserResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchUserResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchUserResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchUserResponse(const PatchUserResponse& from) : PatchUserResponse(nullptr, from) {}
  inline PatchUserResponse(PatchUserResponse&& from) noexcept
      : PatchUserResponse(nullptr, std::move(from)) {}
  inline PatchUserResponse& operator=(const PatchUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchUserResponse& operator=(PatchUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchUserResponse* internal_default_instance() {
    return reinterpret_cast<const PatchUserResponse*>(
        &_PatchUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(PatchUserResponse& a, PatchUserResponse& b) { a.Swap(&b); }
  inline void Swap(PatchUserResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchUserResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchUserResponse& from) { PatchUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchUserResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.PatchUserResponse"; }

 protected:
  explicit PatchUserResponse(::google::protobuf::Arena* arena);
  PatchUserResponse(::google::protobuf::Arena* arena, const PatchUserResponse& from);
  PatchUserResponse(::google::protobuf::Arena* arena, PatchUserResponse&& from) noexcept
      : PatchUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.User user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.PatchUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchUserResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::User* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class PatchUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.PatchUserRequest) */ {
 public:
  inline PatchUserRequest() : PatchUserRequest(nullptr) {}
  ~PatchUserRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchUserRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchUserRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchUserRequest(const PatchUserRequest& from) : PatchUserRequest(nullptr, from) {}
  inline PatchUserRequest(PatchUserRequest&& from) noexcept
      : PatchUserRequest(nullptr, std::move(from)) {}
  inline PatchUserRequest& operator=(const PatchUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchUserRequest& operator=(PatchUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchUserRequest* internal_default_instance() {
    return reinterpret_cast<const PatchUserRequest*>(
        &_PatchUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(PatchUserRequest& a, PatchUserRequest& b) { a.Swap(&b); }
  inline void Swap(PatchUserRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchUserRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchUserRequest& from) { PatchUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchUserRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.PatchUserRequest"; }

 protected:
  explicit PatchUserRequest(::google::protobuf::Arena* arena);
  PatchUserRequest(::google::protobuf::Arena* arena, const PatchUserRequest& from);
  PatchUserRequest(::google::protobuf::Arena* arena, PatchUserRequest&& from) noexcept
      : PatchUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
    kAssignedByFieldNumber = 2,
  };
  // .user.User user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // optional int64 assigned_by = 2;
  bool has_assigned_by() const;
  void clear_assigned_by() ;
  ::int64_t assigned_by() const;
  void set_assigned_by(::int64_t value);

  private:
  ::int64_t _internal_assigned_by() const;
  void _internal_set_assigned_by(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.PatchUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchUserRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::User* user_;
    ::int64_t assigned_by_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoginResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoginResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginResponse(const LoginResponse& from) : LoginResponse(nullptr, from) {}
  inline LoginResponse(LoginResponse&& from) noexcept
      : LoginResponse(nullptr, std::move(from)) {}
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
        &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LoginResponse& a, LoginResponse& b) { a.Swap(&b); }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoginResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginResponse& from) { LoginResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoginResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.LoginResponse"; }

 protected:
  explicit LoginResponse(::google::protobuf::Arena* arena);
  LoginResponse(::google::protobuf::Arena* arena, const LoginResponse& from);
  LoginResponse(::google::protobuf::Arena* arena, LoginResponse&& from) noexcept
      : LoginResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kUserFieldNumber = 2,
    kIsCompletedFieldNumber = 3,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .user.User user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // bool is_completed = 3;
  void clear_is_completed() ;
  bool is_completed() const;
  void set_is_completed(bool value);

  private:
  bool _internal_is_completed() const;
  void _internal_set_is_completed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:user.LoginResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::user::User* user_;
    bool is_completed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUsersResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.ListUsersResponse) */ {
 public:
  inline ListUsersResponse() : ListUsersResponse(nullptr) {}
  ~ListUsersResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListUsersResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListUsersResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListUsersResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListUsersResponse(const ListUsersResponse& from) : ListUsersResponse(nullptr, from) {}
  inline ListUsersResponse(ListUsersResponse&& from) noexcept
      : ListUsersResponse(nullptr, std::move(from)) {}
  inline ListUsersResponse& operator=(const ListUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersResponse& operator=(ListUsersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListUsersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListUsersResponse* internal_default_instance() {
    return reinterpret_cast<const ListUsersResponse*>(
        &_ListUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ListUsersResponse& a, ListUsersResponse& b) { a.Swap(&b); }
  inline void Swap(ListUsersResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListUsersResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListUsersResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListUsersResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListUsersResponse& from) { ListUsersResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListUsersResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.ListUsersResponse"; }

 protected:
  explicit ListUsersResponse(::google::protobuf::Arena* arena);
  ListUsersResponse(::google::protobuf::Arena* arena, const ListUsersResponse& from);
  ListUsersResponse(::google::protobuf::Arena* arena, ListUsersResponse&& from) noexcept
      : ListUsersResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .user.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;

  public:
  void clear_users() ;
  ::user::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField<::user::User>* mutable_users();

  private:
  const ::google::protobuf::RepeatedPtrField<::user::User>& _internal_users() const;
  ::google::protobuf::RepeatedPtrField<::user::User>* _internal_mutable_users();
  public:
  const ::user::User& users(int index) const;
  ::user::User* add_users();
  const ::google::protobuf::RepeatedPtrField<::user::User>& users() const;
  // @@protoc_insertion_point(class_scope:user.ListUsersResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListUsersResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::user::User > users_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.GetUserResponse) */ {
 public:
  inline GetUserResponse() : GetUserResponse(nullptr) {}
  ~GetUserResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetUserResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetUserResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetUserResponse(const GetUserResponse& from) : GetUserResponse(nullptr, from) {}
  inline GetUserResponse(GetUserResponse&& from) noexcept
      : GetUserResponse(nullptr, std::move(from)) {}
  inline GetUserResponse& operator=(const GetUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserResponse& operator=(GetUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserResponse*>(
        &_GetUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetUserResponse& a, GetUserResponse& b) { a.Swap(&b); }
  inline void Swap(GetUserResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetUserResponse& from) { GetUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetUserResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.GetUserResponse"; }

 protected:
  explicit GetUserResponse(::google::protobuf::Arena* arena);
  GetUserResponse(::google::protobuf::Arena* arena, const GetUserResponse& from);
  GetUserResponse(::google::protobuf::Arena* arena, GetUserResponse&& from) noexcept
      : GetUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.User user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.GetUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetUserResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::User* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.CreateUserResponse) */ {
 public:
  inline CreateUserResponse() : CreateUserResponse(nullptr) {}
  ~CreateUserResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateUserResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateUserResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateUserResponse(const CreateUserResponse& from) : CreateUserResponse(nullptr, from) {}
  inline CreateUserResponse(CreateUserResponse&& from) noexcept
      : CreateUserResponse(nullptr, std::move(from)) {}
  inline CreateUserResponse& operator=(const CreateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserResponse& operator=(CreateUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUserResponse* internal_default_instance() {
    return reinterpret_cast<const CreateUserResponse*>(
        &_CreateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CreateUserResponse& a, CreateUserResponse& b) { a.Swap(&b); }
  inline void Swap(CreateUserResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUserResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateUserResponse& from) { CreateUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateUserResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.CreateUserResponse"; }

 protected:
  explicit CreateUserResponse(::google::protobuf::Arena* arena);
  CreateUserResponse(::google::protobuf::Arena* arena, const CreateUserResponse& from);
  CreateUserResponse(::google::protobuf::Arena* arena, CreateUserResponse&& from) noexcept
      : CreateUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
  };
  // .user.User user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:user.CreateUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateUserResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::User* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:user.CreateUserRequest) */ {
 public:
  inline CreateUserRequest() : CreateUserRequest(nullptr) {}
  ~CreateUserRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateUserRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateUserRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateUserRequest(const CreateUserRequest& from) : CreateUserRequest(nullptr, from) {}
  inline CreateUserRequest(CreateUserRequest&& from) noexcept
      : CreateUserRequest(nullptr, std::move(from)) {}
  inline CreateUserRequest& operator=(const CreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserRequest& operator=(CreateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const CreateUserRequest*>(
        &_CreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CreateUserRequest& a, CreateUserRequest& b) { a.Swap(&b); }
  inline void Swap(CreateUserRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUserRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateUserRequest& from) { CreateUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateUserRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "user.CreateUserRequest"; }

 protected:
  explicit CreateUserRequest(::google::protobuf::Arena* arena);
  CreateUserRequest(::google::protobuf::Arena* arena, const CreateUserRequest& from);
  CreateUserRequest(::google::protobuf::Arena* arena, CreateUserRequest&& from) noexcept
      : CreateUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
    kAssignedByFieldNumber = 2,
  };
  // .user.User user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::user::User& user() const;
  PROTOBUF_NODISCARD ::user::User* release_user();
  ::user::User* mutable_user();
  void set_allocated_user(::user::User* value);
  void unsafe_arena_set_allocated_user(::user::User* value);
  ::user::User* unsafe_arena_release_user();

  private:
  const ::user::User& _internal_user() const;
  ::user::User* _internal_mutable_user();

  public:
  // optional int64 assigned_by = 2;
  bool has_assigned_by() const;
  void clear_assigned_by() ;
  ::int64_t assigned_by() const;
  void set_assigned_by(::int64_t value);

  private:
  ::int64_t _internal_assigned_by() const;
  void _internal_set_assigned_by(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:user.CreateUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateUserRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::user::User* user_;
    ::int64_t assigned_by_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fuser_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// User

// optional int64 id = 1;
inline bool User::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void User::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int64_t User::id() const {
  // @@protoc_insertion_point(field_get:user.User.id)
  return _internal_id();
}
inline void User::set_id(::int64_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:user.User.id)
}
inline ::int64_t User::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void User::_internal_set_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// optional string email = 2;
inline bool User::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void User::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& User::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.email)
}
inline std::string* User::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:user.User.email)
  return _s;
}
inline const std::string& User::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void User::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* User::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.email)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.email_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.email_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.email)
}

// optional string password_hash = 3;
inline bool User::has_password_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void User::clear_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& User::password_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.password_hash)
  return _internal_password_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_password_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.password_hash)
}
inline std::string* User::mutable_password_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password_hash();
  // @@protoc_insertion_point(field_mutable:user.User.password_hash)
  return _s;
}
inline const std::string& User::_internal_password_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_hash_.Get();
}
inline void User::_internal_set_password_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_hash_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_hash_.Mutable( GetArena());
}
inline std::string* User::release_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.password_hash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_hash_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_password_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_hash_.IsDefault()) {
    _impl_.password_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.password_hash)
}

// optional string phone_number = 4;
inline bool User::has_phone_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void User::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& User::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.phone_number)
}
inline std::string* User::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:user.User.phone_number)
  return _s;
}
inline const std::string& User::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void User::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* User::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.phone_number)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.phone_number_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.phone_number_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_number_.IsDefault()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.phone_number)
}

// optional string first_name = 5;
inline bool User::has_first_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void User::clear_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& User::first_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.first_name)
  return _internal_first_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_first_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.first_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.first_name)
}
inline std::string* User::mutable_first_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:user.User.first_name)
  return _s;
}
inline const std::string& User::_internal_first_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_name_.Get();
}
inline void User::_internal_set_first_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.first_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.first_name_.Mutable( GetArena());
}
inline std::string* User::release_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.first_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.first_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.first_name_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_first_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.first_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.first_name)
}

// optional string last_name = 6;
inline bool User::has_last_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void User::clear_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& User::last_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.last_name)
  return _internal_last_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_last_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.last_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.last_name)
}
inline std::string* User::mutable_last_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:user.User.last_name)
  return _s;
}
inline const std::string& User::_internal_last_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_name_.Get();
}
inline void User::_internal_set_last_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.last_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.last_name_.Mutable( GetArena());
}
inline std::string* User::release_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.last_name)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.last_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.last_name_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_last_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.last_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.last_name)
}

// optional int64 organization_id = 7;
inline bool User::has_organization_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void User::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int64_t User::organization_id() const {
  // @@protoc_insertion_point(field_get:user.User.organization_id)
  return _internal_organization_id();
}
inline void User::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:user.User.organization_id)
}
inline ::int64_t User::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void User::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// optional string organization_name = 8;
inline bool User::has_organization_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void User::clear_organization_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& User::organization_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.organization_name)
  return _internal_organization_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_organization_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.organization_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.organization_name)
}
inline std::string* User::mutable_organization_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_organization_name();
  // @@protoc_insertion_point(field_mutable:user.User.organization_name)
  return _s;
}
inline const std::string& User::_internal_organization_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_name_.Get();
}
inline void User::_internal_set_organization_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.organization_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_organization_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.organization_name_.Mutable( GetArena());
}
inline std::string* User::release_organization_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.organization_name)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.organization_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.organization_name_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_organization_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.organization_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.organization_name_.IsDefault()) {
    _impl_.organization_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.organization_name)
}

// optional string organization_type = 9;
inline bool User::has_organization_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void User::clear_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& User::organization_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.organization_type)
  return _internal_organization_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_organization_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.organization_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.organization_type)
}
inline std::string* User::mutable_organization_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_organization_type();
  // @@protoc_insertion_point(field_mutable:user.User.organization_type)
  return _s;
}
inline const std::string& User::_internal_organization_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_type_.Get();
}
inline void User::_internal_set_organization_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.organization_type_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.organization_type_.Mutable( GetArena());
}
inline std::string* User::release_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.organization_type)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.organization_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.organization_type_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_organization_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.organization_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.organization_type_.IsDefault()) {
    _impl_.organization_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.organization_type)
}

// optional string created_at = 10;
inline bool User::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void User::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& User::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.created_at)
}
inline std::string* User::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:user.User.created_at)
  return _s;
}
inline const std::string& User::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void User::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* User::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.created_at)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.created_at_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.created_at_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.created_at)
}

// optional string updated_at = 11;
inline bool User::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void User::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& User::updated_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.updated_at)
  return _internal_updated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_updated_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.updated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.User.updated_at)
}
inline std::string* User::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:user.User.updated_at)
  return _s;
}
inline const std::string& User::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_.Get();
}
inline void User::_internal_set_updated_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.updated_at_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.updated_at_.Mutable( GetArena());
}
inline std::string* User::release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.updated_at)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.updated_at_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.updated_at_.Set("", GetArena());
  }
  return released;
}
inline void User::set_allocated_updated_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.updated_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.updated_at_.IsDefault()) {
    _impl_.updated_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.User.updated_at)
}

// optional .user.RoleModel role = 12;
inline bool User::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void User::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::user::RoleModel& User::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::RoleModel* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::RoleModel&>(::user::_RoleModel_default_instance_);
}
inline const ::user::RoleModel& User::role() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.User.role)
  return _internal_role();
}
inline void User::unsafe_arena_set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.User.role)
}
inline ::user::RoleModel* User::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::user::RoleModel* released = _impl_.role_;
  _impl_.role_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::RoleModel* User::unsafe_arena_release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.User.role)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::user::RoleModel* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::user::RoleModel* User::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::RoleModel>(GetArena());
    _impl_.role_ = reinterpret_cast<::user::RoleModel*>(p);
  }
  return _impl_.role_;
}
inline ::user::RoleModel* User::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::user::RoleModel* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:user.User.role)
  return _msg;
}
inline void User::set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.User.role)
}

// -------------------------------------------------------------------

// UserModel

// optional int64 id = 1;
inline bool UserModel::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserModel::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t UserModel::id() const {
  // @@protoc_insertion_point(field_get:user.UserModel.id)
  return _internal_id();
}
inline void UserModel::set_id(::int64_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:user.UserModel.id)
}
inline ::int64_t UserModel::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void UserModel::_internal_set_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// optional string email = 2;
inline bool UserModel::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserModel::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserModel::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.email)
}
inline std::string* UserModel::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:user.UserModel.email)
  return _s;
}
inline const std::string& UserModel::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void UserModel::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserModel::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.email)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.email_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.email_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.email)
}

// optional string password_hash = 3;
inline bool UserModel::has_password_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserModel::clear_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserModel::password_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.password_hash)
  return _internal_password_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_password_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.password_hash)
}
inline std::string* UserModel::mutable_password_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password_hash();
  // @@protoc_insertion_point(field_mutable:user.UserModel.password_hash)
  return _s;
}
inline const std::string& UserModel::_internal_password_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_hash_.Get();
}
inline void UserModel::_internal_set_password_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_hash_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_hash_.Mutable( GetArena());
}
inline std::string* UserModel::release_password_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.password_hash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_hash_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_password_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_hash_.IsDefault()) {
    _impl_.password_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.password_hash)
}

// optional string first_name = 4;
inline bool UserModel::has_first_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserModel::clear_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserModel::first_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.first_name)
  return _internal_first_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_first_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.first_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.first_name)
}
inline std::string* UserModel::mutable_first_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:user.UserModel.first_name)
  return _s;
}
inline const std::string& UserModel::_internal_first_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_name_.Get();
}
inline void UserModel::_internal_set_first_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.first_name_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.first_name_.Mutable( GetArena());
}
inline std::string* UserModel::release_first_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.first_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.first_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.first_name_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_first_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.first_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.first_name)
}

// optional string last_name = 5;
inline bool UserModel::has_last_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserModel::clear_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserModel::last_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.last_name)
  return _internal_last_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_last_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.last_name)
}
inline std::string* UserModel::mutable_last_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:user.UserModel.last_name)
  return _s;
}
inline const std::string& UserModel::_internal_last_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_name_.Get();
}
inline void UserModel::_internal_set_last_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_name_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.last_name_.Mutable( GetArena());
}
inline std::string* UserModel::release_last_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.last_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.last_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.last_name_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_last_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.last_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.last_name)
}

// optional string phone_number = 6;
inline bool UserModel::has_phone_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserModel::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserModel::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.phone_number)
}
inline std::string* UserModel::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:user.UserModel.phone_number)
  return _s;
}
inline const std::string& UserModel::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void UserModel::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* UserModel::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.phone_number)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.phone_number_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.phone_number_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_number_.IsDefault()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.phone_number)
}

// optional int64 organization_id = 7;
inline bool UserModel::has_organization_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserModel::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int64_t UserModel::organization_id() const {
  // @@protoc_insertion_point(field_get:user.UserModel.organization_id)
  return _internal_organization_id();
}
inline void UserModel::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:user.UserModel.organization_id)
}
inline ::int64_t UserModel::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void UserModel::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// optional string organization_type = 8;
inline bool UserModel::has_organization_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserModel::clear_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserModel::organization_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.organization_type)
  return _internal_organization_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_organization_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.organization_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.organization_type)
}
inline std::string* UserModel::mutable_organization_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_organization_type();
  // @@protoc_insertion_point(field_mutable:user.UserModel.organization_type)
  return _s;
}
inline const std::string& UserModel::_internal_organization_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_type_.Get();
}
inline void UserModel::_internal_set_organization_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.organization_type_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.organization_type_.Mutable( GetArena());
}
inline std::string* UserModel::release_organization_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.organization_type)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.organization_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.organization_type_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_organization_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.organization_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.organization_type_.IsDefault()) {
    _impl_.organization_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.organization_type)
}

// optional string created_at = 9;
inline bool UserModel::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserModel::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserModel::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.created_at)
}
inline std::string* UserModel::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:user.UserModel.created_at)
  return _s;
}
inline const std::string& UserModel::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void UserModel::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* UserModel::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.created_at)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.created_at_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.created_at_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.created_at)
}

// optional string updated_at = 10;
inline bool UserModel::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserModel::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserModel::updated_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UserModel.updated_at)
  return _internal_updated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserModel::set_updated_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.updated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.UserModel.updated_at)
}
inline std::string* UserModel::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:user.UserModel.updated_at)
  return _s;
}
inline const std::string& UserModel::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_.Get();
}
inline void UserModel::_internal_set_updated_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.updated_at_.Set(value, GetArena());
}
inline std::string* UserModel::_internal_mutable_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.updated_at_.Mutable( GetArena());
}
inline std::string* UserModel::release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UserModel.updated_at)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.updated_at_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.updated_at_.Set("", GetArena());
  }
  return released;
}
inline void UserModel::set_allocated_updated_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.updated_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.updated_at_.IsDefault()) {
    _impl_.updated_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserModel.updated_at)
}

// -------------------------------------------------------------------

// RoleModel

// optional int64 role_id = 1;
inline bool RoleModel::has_role_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RoleModel::clear_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t RoleModel::role_id() const {
  // @@protoc_insertion_point(field_get:user.RoleModel.role_id)
  return _internal_role_id();
}
inline void RoleModel::set_role_id(::int64_t value) {
  _internal_set_role_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:user.RoleModel.role_id)
}
inline ::int64_t RoleModel::_internal_role_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_id_;
}
inline void RoleModel::_internal_set_role_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = value;
}

// string role_name = 2;
inline void RoleModel::clear_role_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_name_.ClearToEmpty();
}
inline const std::string& RoleModel::role_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.RoleModel.role_name)
  return _internal_role_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoleModel::set_role_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.RoleModel.role_name)
}
inline std::string* RoleModel::mutable_role_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:user.RoleModel.role_name)
  return _s;
}
inline const std::string& RoleModel::_internal_role_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_name_.Get();
}
inline void RoleModel::_internal_set_role_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_name_.Set(value, GetArena());
}
inline std::string* RoleModel::_internal_mutable_role_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.role_name_.Mutable( GetArena());
}
inline std::string* RoleModel::release_role_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.RoleModel.role_name)
  return _impl_.role_name_.Release();
}
inline void RoleModel::set_allocated_role_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.role_name_.IsDefault()) {
    _impl_.role_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.RoleModel.role_name)
}

// optional string description = 3;
inline bool RoleModel::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RoleModel::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoleModel::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.RoleModel.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoleModel::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.RoleModel.description)
}
inline std::string* RoleModel::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:user.RoleModel.description)
  return _s;
}
inline const std::string& RoleModel::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void RoleModel::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* RoleModel::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* RoleModel::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.RoleModel.description)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void RoleModel::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.RoleModel.description)
}

// optional int64 organization_id = 4;
inline bool RoleModel::has_organization_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RoleModel::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t RoleModel::organization_id() const {
  // @@protoc_insertion_point(field_get:user.RoleModel.organization_id)
  return _internal_organization_id();
}
inline void RoleModel::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:user.RoleModel.organization_id)
}
inline ::int64_t RoleModel::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void RoleModel::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// -------------------------------------------------------------------

// UserRoleModel

// optional int64 user_id = 1;
inline bool UserRoleModel::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserRoleModel::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t UserRoleModel::user_id() const {
  // @@protoc_insertion_point(field_get:user.UserRoleModel.user_id)
  return _internal_user_id();
}
inline void UserRoleModel::set_user_id(::int64_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:user.UserRoleModel.user_id)
}
inline ::int64_t UserRoleModel::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void UserRoleModel::_internal_set_user_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// int64 role_id = 2;
inline void UserRoleModel::clear_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = ::int64_t{0};
}
inline ::int64_t UserRoleModel::role_id() const {
  // @@protoc_insertion_point(field_get:user.UserRoleModel.role_id)
  return _internal_role_id();
}
inline void UserRoleModel::set_role_id(::int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:user.UserRoleModel.role_id)
}
inline ::int64_t UserRoleModel::_internal_role_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_id_;
}
inline void UserRoleModel::_internal_set_role_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = value;
}

// int64 assigned_by = 3;
inline void UserRoleModel::clear_assigned_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = ::int64_t{0};
}
inline ::int64_t UserRoleModel::assigned_by() const {
  // @@protoc_insertion_point(field_get:user.UserRoleModel.assigned_by)
  return _internal_assigned_by();
}
inline void UserRoleModel::set_assigned_by(::int64_t value) {
  _internal_set_assigned_by(value);
  // @@protoc_insertion_point(field_set:user.UserRoleModel.assigned_by)
}
inline ::int64_t UserRoleModel::_internal_assigned_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_by_;
}
inline void UserRoleModel::_internal_set_assigned_by(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = value;
}

// int64 organization_id = 4;
inline void UserRoleModel::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
}
inline ::int64_t UserRoleModel::organization_id() const {
  // @@protoc_insertion_point(field_get:user.UserRoleModel.organization_id)
  return _internal_organization_id();
}
inline void UserRoleModel::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:user.UserRoleModel.organization_id)
}
inline ::int64_t UserRoleModel::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void UserRoleModel::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// string login = 1;
inline void LoginRequest::clear_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_.ClearToEmpty();
}
inline const std::string& LoginRequest::login() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.LoginRequest.login)
  return _internal_login();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_login(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.LoginRequest.login)
}
inline std::string* LoginRequest::mutable_login() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.login)
  return _s;
}
inline const std::string& LoginRequest::_internal_login() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.login_.Get();
}
inline void LoginRequest::_internal_set_login(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.login_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.LoginRequest.login)
  return _impl_.login_.Release();
}
inline void LoginRequest::set_allocated_login(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.login)
}

// string platform = 2;
inline void LoginRequest::clear_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& LoginRequest::platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.LoginRequest.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_platform(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.LoginRequest.platform)
}
inline std::string* LoginRequest::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.platform)
  return _s;
}
inline const std::string& LoginRequest::_internal_platform() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.platform_.Get();
}
inline void LoginRequest::_internal_set_platform(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.platform_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.LoginRequest.platform)
  return _impl_.platform_.Release();
}
inline void LoginRequest::set_allocated_platform(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.platform)
}

// string password = 3;
inline void LoginRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.LoginRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// string token = 1;
inline void LoginResponse::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& LoginResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.LoginResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.LoginResponse.token)
}
inline std::string* LoginResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:user.LoginResponse.token)
  return _s;
}
inline const std::string& LoginResponse::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void LoginResponse::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.LoginResponse.token)
  return _impl_.token_.Release();
}
inline void LoginResponse::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.LoginResponse.token)
}

// .user.User user = 2;
inline bool LoginResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void LoginResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& LoginResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& LoginResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.LoginResponse.user)
  return _internal_user();
}
inline void LoginResponse::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginResponse.user)
}
inline ::user::User* LoginResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* LoginResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.LoginResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* LoginResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* LoginResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.LoginResponse.user)
  return _msg;
}
inline void LoginResponse::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.LoginResponse.user)
}

// bool is_completed = 3;
inline void LoginResponse::clear_is_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_completed_ = false;
}
inline bool LoginResponse::is_completed() const {
  // @@protoc_insertion_point(field_get:user.LoginResponse.is_completed)
  return _internal_is_completed();
}
inline void LoginResponse::set_is_completed(bool value) {
  _internal_set_is_completed(value);
  // @@protoc_insertion_point(field_set:user.LoginResponse.is_completed)
}
inline bool LoginResponse::_internal_is_completed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_completed_;
}
inline void LoginResponse::_internal_set_is_completed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_completed_ = value;
}

// -------------------------------------------------------------------

// RegisterRequest

// .user.UserModel user = 1;
inline bool RegisterRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void RegisterRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::UserModel& RegisterRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::UserModel* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::UserModel&>(::user::_UserModel_default_instance_);
}
inline const ::user::UserModel& RegisterRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.RegisterRequest.user)
  return _internal_user();
}
inline void RegisterRequest::unsafe_arena_set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.RegisterRequest.user)
}
inline ::user::UserModel* RegisterRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::UserModel* RegisterRequest::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.RegisterRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::UserModel* RegisterRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::UserModel>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::UserModel*>(p);
  }
  return _impl_.user_;
}
inline ::user::UserModel* RegisterRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::UserModel* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.RegisterRequest.user)
  return _msg;
}
inline void RegisterRequest::set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.RegisterRequest.user)
}

// -------------------------------------------------------------------

// RegisterResponse

// string token = 1;
inline void RegisterResponse::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& RegisterResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.RegisterResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:user.RegisterResponse.token)
}
inline std::string* RegisterResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:user.RegisterResponse.token)
  return _s;
}
inline const std::string& RegisterResponse::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void RegisterResponse::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* RegisterResponse::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* RegisterResponse::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.RegisterResponse.token)
  return _impl_.token_.Release();
}
inline void RegisterResponse::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:user.RegisterResponse.token)
}

// .user.UserModel user = 2;
inline bool RegisterResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void RegisterResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::UserModel& RegisterResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::UserModel* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::UserModel&>(::user::_UserModel_default_instance_);
}
inline const ::user::UserModel& RegisterResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.RegisterResponse.user)
  return _internal_user();
}
inline void RegisterResponse::unsafe_arena_set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.RegisterResponse.user)
}
inline ::user::UserModel* RegisterResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::UserModel* RegisterResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.RegisterResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::UserModel* RegisterResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::UserModel>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::UserModel*>(p);
  }
  return _impl_.user_;
}
inline ::user::UserModel* RegisterResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::UserModel* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.RegisterResponse.user)
  return _msg;
}
inline void RegisterResponse::set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.RegisterResponse.user)
}

// -------------------------------------------------------------------

// CreateUserRequest

// .user.User user = 1;
inline bool CreateUserRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void CreateUserRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& CreateUserRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& CreateUserRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.CreateUserRequest.user)
  return _internal_user();
}
inline void CreateUserRequest::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.CreateUserRequest.user)
}
inline ::user::User* CreateUserRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* CreateUserRequest::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.CreateUserRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* CreateUserRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* CreateUserRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.CreateUserRequest.user)
  return _msg;
}
inline void CreateUserRequest::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.CreateUserRequest.user)
}

// optional int64 assigned_by = 2;
inline bool CreateUserRequest::has_assigned_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CreateUserRequest::clear_assigned_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t CreateUserRequest::assigned_by() const {
  // @@protoc_insertion_point(field_get:user.CreateUserRequest.assigned_by)
  return _internal_assigned_by();
}
inline void CreateUserRequest::set_assigned_by(::int64_t value) {
  _internal_set_assigned_by(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:user.CreateUserRequest.assigned_by)
}
inline ::int64_t CreateUserRequest::_internal_assigned_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_by_;
}
inline void CreateUserRequest::_internal_set_assigned_by(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = value;
}

// -------------------------------------------------------------------

// CreateUserResponse

// .user.User user = 1;
inline bool CreateUserResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void CreateUserResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& CreateUserResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& CreateUserResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.CreateUserResponse.user)
  return _internal_user();
}
inline void CreateUserResponse::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.CreateUserResponse.user)
}
inline ::user::User* CreateUserResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* CreateUserResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.CreateUserResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* CreateUserResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* CreateUserResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.CreateUserResponse.user)
  return _msg;
}
inline void CreateUserResponse::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.CreateUserResponse.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .user.UserModel user = 1;
inline bool UpdateUserRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UpdateUserRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::UserModel& UpdateUserRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::UserModel* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::UserModel&>(::user::_UserModel_default_instance_);
}
inline const ::user::UserModel& UpdateUserRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdateUserRequest.user)
}
inline ::user::UserModel* UpdateUserRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::UserModel* UpdateUserRequest::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UpdateUserRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::UserModel* UpdateUserRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::UserModel>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::UserModel*>(p);
  }
  return _impl_.user_;
}
inline ::user::UserModel* UpdateUserRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::UserModel* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.UpdateUserRequest.user)
  return _msg;
}
inline void UpdateUserRequest::set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.UpdateUserRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserResponse

// .user.UserModel user = 1;
inline bool UpdateUserResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UpdateUserResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::UserModel& UpdateUserResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::UserModel* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::UserModel&>(::user::_UserModel_default_instance_);
}
inline const ::user::UserModel& UpdateUserResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UpdateUserResponse.user)
  return _internal_user();
}
inline void UpdateUserResponse::unsafe_arena_set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdateUserResponse.user)
}
inline ::user::UserModel* UpdateUserResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::UserModel* UpdateUserResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UpdateUserResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::UserModel* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::UserModel* UpdateUserResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::UserModel>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::UserModel*>(p);
  }
  return _impl_.user_;
}
inline ::user::UserModel* UpdateUserResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::UserModel* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.UpdateUserResponse.user)
  return _msg;
}
inline void UpdateUserResponse::set_allocated_user(::user::UserModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::UserModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.UpdateUserResponse.user)
}

// -------------------------------------------------------------------

// PatchUserRequest

// .user.User user = 1;
inline bool PatchUserRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void PatchUserRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& PatchUserRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& PatchUserRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.PatchUserRequest.user)
  return _internal_user();
}
inline void PatchUserRequest::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.PatchUserRequest.user)
}
inline ::user::User* PatchUserRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* PatchUserRequest::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.PatchUserRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* PatchUserRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* PatchUserRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.PatchUserRequest.user)
  return _msg;
}
inline void PatchUserRequest::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.PatchUserRequest.user)
}

// optional int64 assigned_by = 2;
inline bool PatchUserRequest::has_assigned_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PatchUserRequest::clear_assigned_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t PatchUserRequest::assigned_by() const {
  // @@protoc_insertion_point(field_get:user.PatchUserRequest.assigned_by)
  return _internal_assigned_by();
}
inline void PatchUserRequest::set_assigned_by(::int64_t value) {
  _internal_set_assigned_by(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:user.PatchUserRequest.assigned_by)
}
inline ::int64_t PatchUserRequest::_internal_assigned_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_by_;
}
inline void PatchUserRequest::_internal_set_assigned_by(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_by_ = value;
}

// -------------------------------------------------------------------

// PatchUserResponse

// .user.User user = 1;
inline bool PatchUserResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void PatchUserResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& PatchUserResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& PatchUserResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.PatchUserResponse.user)
  return _internal_user();
}
inline void PatchUserResponse::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.PatchUserResponse.user)
}
inline ::user::User* PatchUserResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* PatchUserResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.PatchUserResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* PatchUserResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* PatchUserResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.PatchUserResponse.user)
  return _msg;
}
inline void PatchUserResponse::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.PatchUserResponse.user)
}

// -------------------------------------------------------------------

// GetUserRequest

// int64 user_id = 1;
inline void GetUserRequest::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = ::int64_t{0};
}
inline ::int64_t GetUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:user.GetUserRequest.user_id)
  return _internal_user_id();
}
inline void GetUserRequest::set_user_id(::int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:user.GetUserRequest.user_id)
}
inline ::int64_t GetUserRequest::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void GetUserRequest::_internal_set_user_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// -------------------------------------------------------------------

// GetUserResponse

// .user.User user = 1;
inline bool GetUserResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void GetUserResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::User& GetUserResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::User&>(::user::_User_default_instance_);
}
inline const ::user::User& GetUserResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.GetUserResponse.user)
  return _internal_user();
}
inline void GetUserResponse::unsafe_arena_set_allocated_user(::user::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.GetUserResponse.user)
}
inline ::user::User* GetUserResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::User* GetUserResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.GetUserResponse.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::user::User* GetUserResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::user::User*>(p);
  }
  return _impl_.user_;
}
inline ::user::User* GetUserResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:user.GetUserResponse.user)
  return _msg;
}
inline void GetUserResponse::set_allocated_user(::user::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::user::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.GetUserResponse.user)
}

// -------------------------------------------------------------------

// ListUsersRequest

// int64 organization_id = 1;
inline void ListUsersRequest::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
}
inline ::int64_t ListUsersRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:user.ListUsersRequest.organization_id)
  return _internal_organization_id();
}
inline void ListUsersRequest::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:user.ListUsersRequest.organization_id)
}
inline ::int64_t ListUsersRequest::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void ListUsersRequest::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// -------------------------------------------------------------------

// ListUsersResponse

// repeated .user.User users = 1;
inline int ListUsersResponse::_internal_users_size() const {
  return _internal_users().size();
}
inline int ListUsersResponse::users_size() const {
  return _internal_users_size();
}
inline void ListUsersResponse::clear_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.users_.Clear();
}
inline ::user::User* ListUsersResponse::mutable_users(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:user.ListUsersResponse.users)
  return _internal_mutable_users()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::user::User>* ListUsersResponse::mutable_users()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:user.ListUsersResponse.users)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_users();
}
inline const ::user::User& ListUsersResponse::users(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.ListUsersResponse.users)
  return _internal_users().Get(index);
}
inline ::user::User* ListUsersResponse::add_users() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::user::User* _add = _internal_mutable_users()->Add();
  // @@protoc_insertion_point(field_add:user.ListUsersResponse.users)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::user::User>& ListUsersResponse::users() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:user.ListUsersResponse.users)
  return _internal_users();
}
inline const ::google::protobuf::RepeatedPtrField<::user::User>&
ListUsersResponse::_internal_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.users_;
}
inline ::google::protobuf::RepeatedPtrField<::user::User>*
ListUsersResponse::_internal_mutable_users() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.users_;
}

// -------------------------------------------------------------------

// DeleteUserRequest

// int64 user_id = 1;
inline void DeleteUserRequest::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = ::int64_t{0};
}
inline ::int64_t DeleteUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:user.DeleteUserRequest.user_id)
  return _internal_user_id();
}
inline void DeleteUserRequest::set_user_id(::int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:user.DeleteUserRequest.user_id)
}
inline ::int64_t DeleteUserRequest::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void DeleteUserRequest::_internal_set_user_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// -------------------------------------------------------------------

// DeleteUserResponse

// bool success = 1;
inline void DeleteUserResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool DeleteUserResponse::success() const {
  // @@protoc_insertion_point(field_get:user.DeleteUserResponse.success)
  return _internal_success();
}
inline void DeleteUserResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:user.DeleteUserResponse.success)
}
inline bool DeleteUserResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void DeleteUserResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// CreateRoleRequest

// .user.RoleModel role = 1;
inline bool CreateRoleRequest::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void CreateRoleRequest::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::RoleModel& CreateRoleRequest::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::RoleModel* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::RoleModel&>(::user::_RoleModel_default_instance_);
}
inline const ::user::RoleModel& CreateRoleRequest::role() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.CreateRoleRequest.role)
  return _internal_role();
}
inline void CreateRoleRequest::unsafe_arena_set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.CreateRoleRequest.role)
}
inline ::user::RoleModel* CreateRoleRequest::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* released = _impl_.role_;
  _impl_.role_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::RoleModel* CreateRoleRequest::unsafe_arena_release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.CreateRoleRequest.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::user::RoleModel* CreateRoleRequest::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::RoleModel>(GetArena());
    _impl_.role_ = reinterpret_cast<::user::RoleModel*>(p);
  }
  return _impl_.role_;
}
inline ::user::RoleModel* CreateRoleRequest::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::RoleModel* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:user.CreateRoleRequest.role)
  return _msg;
}
inline void CreateRoleRequest::set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.CreateRoleRequest.role)
}

// -------------------------------------------------------------------

// CreateRoleResponse

// .user.RoleModel role = 1;
inline bool CreateRoleResponse::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void CreateRoleResponse::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::RoleModel& CreateRoleResponse::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::RoleModel* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::RoleModel&>(::user::_RoleModel_default_instance_);
}
inline const ::user::RoleModel& CreateRoleResponse::role() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.CreateRoleResponse.role)
  return _internal_role();
}
inline void CreateRoleResponse::unsafe_arena_set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.CreateRoleResponse.role)
}
inline ::user::RoleModel* CreateRoleResponse::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* released = _impl_.role_;
  _impl_.role_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::RoleModel* CreateRoleResponse::unsafe_arena_release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.CreateRoleResponse.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::user::RoleModel* CreateRoleResponse::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::RoleModel>(GetArena());
    _impl_.role_ = reinterpret_cast<::user::RoleModel*>(p);
  }
  return _impl_.role_;
}
inline ::user::RoleModel* CreateRoleResponse::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::RoleModel* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:user.CreateRoleResponse.role)
  return _msg;
}
inline void CreateRoleResponse::set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.CreateRoleResponse.role)
}

// -------------------------------------------------------------------

// ListRolesRequest

// int64 organization_id = 1;
inline void ListRolesRequest::clear_organization_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = ::int64_t{0};
}
inline ::int64_t ListRolesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:user.ListRolesRequest.organization_id)
  return _internal_organization_id();
}
inline void ListRolesRequest::set_organization_id(::int64_t value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:user.ListRolesRequest.organization_id)
}
inline ::int64_t ListRolesRequest::_internal_organization_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.organization_id_;
}
inline void ListRolesRequest::_internal_set_organization_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.organization_id_ = value;
}

// -------------------------------------------------------------------

// ListRolesResponse

// repeated .user.RoleModel roles = 1;
inline int ListRolesResponse::_internal_roles_size() const {
  return _internal_roles().size();
}
inline int ListRolesResponse::roles_size() const {
  return _internal_roles_size();
}
inline void ListRolesResponse::clear_roles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roles_.Clear();
}
inline ::user::RoleModel* ListRolesResponse::mutable_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:user.ListRolesResponse.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::user::RoleModel>* ListRolesResponse::mutable_roles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:user.ListRolesResponse.roles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_roles();
}
inline const ::user::RoleModel& ListRolesResponse::roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.ListRolesResponse.roles)
  return _internal_roles().Get(index);
}
inline ::user::RoleModel* ListRolesResponse::add_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::user::RoleModel* _add = _internal_mutable_roles()->Add();
  // @@protoc_insertion_point(field_add:user.ListRolesResponse.roles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::user::RoleModel>& ListRolesResponse::roles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:user.ListRolesResponse.roles)
  return _internal_roles();
}
inline const ::google::protobuf::RepeatedPtrField<::user::RoleModel>&
ListRolesResponse::_internal_roles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.roles_;
}
inline ::google::protobuf::RepeatedPtrField<::user::RoleModel>*
ListRolesResponse::_internal_mutable_roles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.roles_;
}

// int32 total_count = 2;
inline void ListRolesResponse::clear_total_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_count_ = 0;
}
inline ::int32_t ListRolesResponse::total_count() const {
  // @@protoc_insertion_point(field_get:user.ListRolesResponse.total_count)
  return _internal_total_count();
}
inline void ListRolesResponse::set_total_count(::int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:user.ListRolesResponse.total_count)
}
inline ::int32_t ListRolesResponse::_internal_total_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_count_;
}
inline void ListRolesResponse::_internal_set_total_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_count_ = value;
}

// -------------------------------------------------------------------

// UpdateRoleRequest

// .user.RoleModel role = 1;
inline bool UpdateRoleRequest::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void UpdateRoleRequest::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::RoleModel& UpdateRoleRequest::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::RoleModel* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::RoleModel&>(::user::_RoleModel_default_instance_);
}
inline const ::user::RoleModel& UpdateRoleRequest::role() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UpdateRoleRequest.role)
  return _internal_role();
}
inline void UpdateRoleRequest::unsafe_arena_set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdateRoleRequest.role)
}
inline ::user::RoleModel* UpdateRoleRequest::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* released = _impl_.role_;
  _impl_.role_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::RoleModel* UpdateRoleRequest::unsafe_arena_release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UpdateRoleRequest.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::user::RoleModel* UpdateRoleRequest::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::RoleModel>(GetArena());
    _impl_.role_ = reinterpret_cast<::user::RoleModel*>(p);
  }
  return _impl_.role_;
}
inline ::user::RoleModel* UpdateRoleRequest::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::RoleModel* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:user.UpdateRoleRequest.role)
  return _msg;
}
inline void UpdateRoleRequest::set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.UpdateRoleRequest.role)
}

// -------------------------------------------------------------------

// UpdateRoleResponse

// .user.RoleModel role = 1;
inline bool UpdateRoleResponse::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void UpdateRoleResponse::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::user::RoleModel& UpdateRoleResponse::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::user::RoleModel* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::RoleModel&>(::user::_RoleModel_default_instance_);
}
inline const ::user::RoleModel& UpdateRoleResponse::role() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:user.UpdateRoleResponse.role)
  return _internal_role();
}
inline void UpdateRoleResponse::unsafe_arena_set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdateRoleResponse.role)
}
inline ::user::RoleModel* UpdateRoleResponse::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* released = _impl_.role_;
  _impl_.role_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::user::RoleModel* UpdateRoleResponse::unsafe_arena_release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:user.UpdateRoleResponse.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::user::RoleModel* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::user::RoleModel* UpdateRoleResponse::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.role_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::user::RoleModel>(GetArena());
    _impl_.role_ = reinterpret_cast<::user::RoleModel*>(p);
  }
  return _impl_.role_;
}
inline ::user::RoleModel* UpdateRoleResponse::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::user::RoleModel* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:user.UpdateRoleResponse.role)
  return _msg;
}
inline void UpdateRoleResponse::set_allocated_role(::user::RoleModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::user::RoleModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:user.UpdateRoleResponse.role)
}

// -------------------------------------------------------------------

// DeleteRoleRequest

// int64 role_id = 1;
inline void DeleteRoleRequest::clear_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = ::int64_t{0};
}
inline ::int64_t DeleteRoleRequest::role_id() const {
  // @@protoc_insertion_point(field_get:user.DeleteRoleRequest.role_id)
  return _internal_role_id();
}
inline void DeleteRoleRequest::set_role_id(::int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:user.DeleteRoleRequest.role_id)
}
inline ::int64_t DeleteRoleRequest::_internal_role_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_id_;
}
inline void DeleteRoleRequest::_internal_set_role_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_ = value;
}

// -------------------------------------------------------------------

// DeleteRoleResponse

// bool success = 1;
inline void DeleteRoleResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool DeleteRoleResponse::success() const {
  // @@protoc_insertion_point(field_get:user.DeleteRoleResponse.success)
  return _internal_success();
}
inline void DeleteRoleResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:user.DeleteRoleResponse.success)
}
inline bool DeleteRoleResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void DeleteRoleResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace user


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // user_2fuser_2eproto_2epb_2eh
